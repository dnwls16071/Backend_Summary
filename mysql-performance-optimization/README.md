### ✅ 백엔드 면접에서 물어보는 DB 성능 최적화 경험

* 크게 3가지 요인 때문에 성능 저하를 경험하게 된다. 
  * 동시 사용자 수의 증가
  * 데이터 양의 증가
  * 비효율적인 SQL문 작성

### ✅ DB 성능 개선할 때, SQL 튜닝을 먼저 하는 이유

* DB 성능을 개선하는 방법은 다양하다.
  * SQL 튜닝
  * 캐싱 서버 활용(Redis)
  * 레플리케이션(Master/Slave 구조)
  * 샤딩
  * 스케일업(CPU, Memory, SSD 등 하드웨어 업그레이드)

### ✅ 많은 성능 개선 방법 중에서 왜 SQL 튜닝을 먼저 고려해야하는지?

* 위에 제시된 방법들 중에서 SQL 튜닝을 제외한 나머지 방식들은 추가적인 시스템을 구축해야 한다.
* 따라서, 금전적, 시간적 비용이 추가적으로 발생한다.
* 조금 더 복잡해진 시스템 구조로 인해 관리 비용이 늘어난다. 그에 비해 SQL 튜닝은 기존의 시스템 변경 없이 성능을 개선할 수 있다.
* 근본적인 문제를 해결하는 방법이 SQL 튜닝일 가능성이 높다. SQL 자체가 비효율적으로 작성되었다면 아무리 시스템적으로 성능을 개선한다고 하더라도 한계가 있다.
* 하지만 SQL 튜닝을 통해서 기본적으로 성능을 향상시킨다면 시스템적인 성능 개선이 필요없거나 훨씬 간단한 개선으로도 큰 성능 개선 효과를 얻을 수 있다.

### ✅ 성능 개선을 위한 MySQL 구조 파악 / SQL 튜닝의 핵심

<img src="/image/img1.webp">

1. 클라이언트가 DB에 SQL 요청을 보낸다.
2. MySQL 엔진에서 옵티마이저가 SQL문을 분석한 뒤 빠르고 효율적으로 데이터를 가져올 수 있는 계획을 세운다. 어떤 순서로 테이블에 접근할지, 인덱스를 사용할지, 어떤 인덱스를 사용할지 등을 결정한다.
* 옵티마이저가 세운 계획은 완벽하지 않다. 따라서 SQL 튜닝이 필요하다.
3. 옵티마이저가 세운 계획을 바탕으로 스토리지 엔진에서 데이터를 가져온다.
* DB 성능에 문제가 생기는 대부분의 원인은 스토리지 엔진으로부터 데이터를 가져올 때 발생한다.
* 데이터를 찾기가 어려워서 오래 걸리거나 가져올 데이터가 너무 많아서 오래 걸린다.
* SQL 튜닝의 핵심은 스토리지 엔진으로부터 되도록이면 데이터를 찾기 쉽게 바꾸고, 적은 데이터를 가져오도록 바꾸는 것을 말한다.
4. MySQL 엔진에서 정렬, 필터링 등 마지막 처리를 한 뒤에 클라이언트에게 SQL 결과를 응답한다.

> SQL 튜닝에 있어서 핵심은 2가지이다.
>
> 1. 스토리지 엔진에서 데이터를 찾기 쉽게 바꾸기
> 2. 스토리지 엔진으로부터 가져오는 데이터의 양 줄이기

* 여러 가지 방법이 있겠지만 가장 많이 활용되는 방법은 바로 인덱스 활용이다.
* 단순히 인덱스만 적용한다고 무조건 해결되는 것은 아니다.

### ✅ 인덱스(Index)

> 인덱스(Index)는 데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료구조를 말한다.

* 인덱스 적용 전후의 성능 체크를 위해 100만건의 랜덤 데이터를 삽입한다.

```sql
-- 높은 재귀(반복) 횟수를 허용하도록 설정
-- (아래에서 생성할 더미 데이터의 개수와 맞춰서 작성하면 된다.)
SET SESSION cte_max_recursion_depth = 1000000; 

-- 더미 데이터 삽입 쿼리
INSERT INTO users (name, age)
WITH RECURSIVE cte (n) AS
(
  SELECT 1
  UNION ALL
  SELECT n + 1 FROM cte WHERE n < 1000000 -- 생성하고 싶은 더미 데이터의 개수
)
SELECT 
    CONCAT('User', LPAD(n, 7, '0')),   -- 'User' 다음에 7자리 숫자로 구성된 이름 생성
    FLOOR(1 + RAND() * 1000) AS age    -- 1부터 1000 사이의 랜덤 값으로 나이 생성
FROM cte;

-- 잘 생성됐는 지 확인
SELECT COUNT(*) FROM users;

SELECT * FROM users;
```

* 랜덤 데이터를 넣었으니 이제 age 필드에 대한 인덱스를 만들어보자.

```sql
CREATE INDEX idx_age ON users (age);
```

* 실행 결과 비교

<img src="/image/exec1.png">

* 인덱스 생성 실패 시점 이전의 경우 촤대 0.182s가 소요되었으나 인덱스 생성 성공 시점 이후의 경우 0.059s가 소요된 걸 확인할 수 있다.

### ✅ 기본키(Primary Key, PK)

* 테이블에서 특정 데이터를 식별하기 위한 키를 기본키라고 부른다.
* 대부분의 경우에 테이블을 생성할 때, PK를 설정한다.
* PK의 특징 중 하나는 PK를 기준으로 정렬을 해서 데이터를 보관한다.

<img src="/image/exec2.png">

* id 컬럼을 기준으로 정렬되어 있는 채로 데이터가 조회된다. 왜냐하면 PK가 인덱스의 일종이기 때문이다.
* 이렇게 원본 데이터 자체가 정렬되는 인덱스를 보고 클러스터링 인덱스라고 부른다.
* 클러스터링 인덱스는 PK밖에 없다.

> 결론 : PK에는 인덱스가 기본적으로 적용되고 인덱스가 적용되었기 때문에 PK를 기준으로 데이터가 정렬된다.

### ✅ 제약 조건을 추가하면 자동으로 생성되는 인덱스(UNIQUE)

* MySQL은 `UNIQUE` 제약 조건을 추가하면 자동으로 인덱스가 생성된다.

```java
@Entity
@Table(name = "USERS")
public class User {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;

	// unique 속성 추가
	@Column(name = "name", unique = true)
	private String name;
}
```

* JPA의 옵션(create)에 따라 쿼리 로그문이 호출되는 것을 볼 수 있다.

```sql
2024-12-24T00:48:59.017+09:00 DEBUG 30202 --- [           main] org.hibernate.SQL                        : 
create table users (
                     id bigint not null auto_increment,
                     name varchar(255),
                     primary key (id)
) engine=InnoDB
Hibernate:
create table users (
                     id bigint not null auto_increment,
                     name varchar(255),
                     primary key (id)
) engine=InnoDB
2024-12-24T00:48:59.025+09:00 DEBUG 30202 --- [           main] org.hibernate.SQL                        : 
alter table users
  add constraint UK3g1j96g94xpk3lpxl2qbl985x unique (name)
  Hibernate:
alter table users
  add constraint UK3g1j96g94xpk3lpxl2qbl985x unique (name)
```

* 로그를 자세히 들여다보면 alter 문으로 표시되는 것이 있다. 바로 unique 제약 조건인데 디비버를 통해 다시 한 번 확인해보자.

<img src="/image/unique.png">

* `UNIQUE` 옵션을 사용하면 인덱스가 같이 생성되는데 이 때 생성되는 인덱스를 고유 인덱스(Unique Index)라고 한다.
* `UNIQUE` 옵션을 사용하면 인덱스가 같이 생성되면서 조회 성능이 향상된다.

### ✅ 그러나 인덱스를 무식하게 많이 걸면 안 된다!

* 인덱스를 추가한다는 것은 인덱스용 테이블이 추가적으로 생성된다는 뜻이다.
* 그렇다면 인덱스를 추가하지 않은 상태에서 원래 테이블에만 데이터를 넣는 것보다 인덱스를 추가한 상태에서 원래 테이블과 인덱스용 테이블 둘 다에 테이블 데이터를 넣어야 하는게 더 느릴 수 밖에 없다.
* 인덱스의 개수가 많아지면 데이터를 삽입하는 것 이외에도 수정 / 삭제 작업에서도 같은 이유(인덱스용 테이블의 생성)로 성능이 저하된다.

<img src="/image/many_index.png">

* 인덱스를 많이 걸어준 테이블의 경우 100,000개의 데이터를 넣는데 걸리는 시간은 1s이고 인덱스가 없는 테이블에 데이터 100,000개의 데이터를 넣는데 걸리는 시간은 0.287s이다.

> 결론 : 인덱스는 최소한만 사용하려고 하자. 인덱스를 추가하면 조회 속도는 빨라지나, 쓰기(삽입, 수정, 삭제) 속도는 느려진다.

### ✅ 멀티 컬럼 인덱스(Multi Column Index)
 
* 멀티 컬럼 인덱스란, 2개 이상의 컬럼을 묶어서 설정하는 인덱스를 뜻한다.
* 즉, 데이터를 빨리 찾기 위해 2개 이상의 컬럼을 기준으로 미리 정렬해놓은 것을 말한다.

### ✅ 멀티 컬럼 인덱스 작동 방식

* 2개 이상의 컬럼을 묶어서 멀티 컬럼 인덱스를 아래와 같이 만들어준다.

```sql
CREATE INDEX idx_부서_이름 ON users (부서, 이름);
```

<img src="/image/multi.png">

### ✅ 멀티 컬럼 인덱스 생성 시 주의점

```sql
CREATE INDEX idx_부서_이름 ON users (부서, 이름);
```

* 위와 같은 인덱스를 생성하게 되면 `부서`를 기준으로 먼저 정렬이 되고, 그 다음 같은 `부서`내에서 `이름`을 기준으로 정렬되어 있다.
* 이런 구조로 되어 있기 때문에 `부서`컬럼만 놓고 봤을 때는 `부서`인덱스와 동일한 정렬 상태를 가진다.
* 따라서 위의 멀티 컬럼 인덱스 구조를 활용하면 `부서`의 인덱스를 활용하듯이 쓸 수도 있다.
* 예시는 바로 아래와 같다.

```sql
SELECT * FROM users WHERE 부서 = '운영';
```

* 부서 인덱스를 만들면 성능이 늘어날 것이라고 생각을 하지만 사실 부서 인덱스를 만들지 않고도 성능 향상을 도모할 수 있다.
* 왜냐하면 멀티 컬럼 인덱스를 만들면서 부서 기준으로 이미 정렬이 되어 있기 때문에 부서 인덱스를 또 만들 필요가 없다는 것이다.
* 하지만 부서 기준으로는 정렬이 되어 있으나 이름 기준으로는 정렬이 되어 있지 않다. 따라서 이 멀티 컬럼 인덱스를 이름 일반 인덱스로는 활용할 수 없다.

> 결론 : 멀티 컬럼 인덱스에서 일반 인덱스처럼 활용할 수 있는 것은 처음에 배치된 컬럼뿐이다.

### ✅ 멀티 컬럼 인덱스 구성 팁 : 소분류 -> 중분류 -> 대분류 컬럼순으로 구성하기

* 멀티 컬럼 인덱스를 만들 때에는 순서에 주의해야 한다.
* 예시를 들어보자.

```text
어느 대기업에서 회계부서의 박미나를 찾아야 한다고 가정할 때, 다음과 같은 두 가지 방법이 있을 수 있다.

- 회계부서의 모든 인원을 만나본 뒤에 박미나를 찾을지
- 박미나라는 이름을 가진 사람들한테 찾아서 회계부서인지 물어볼지
```

* 후자 케이스가 더 빨리 찾을 수 있다는 것을 알 수 있다.
* 이를 일반화해서 표현하자면 박미나라는 이름(소분류)을 먼저 탐색한 뒤, 회계 부서라는 부서(대분류)를 탐색하는게 빠르다고 할 수 있다.
* 멀티 컬럼 인덱스에서도 배치한 컬럼 순서대로 데이터를 탐색한다. [이름, 부서] 순서대로라면 이름을 먼저 찾고 그 다음 부서를 찾는 식으로 처리한다.

### ✅ 실행 계획(Explain)을 활용해 성능 저하 요인 찾아내기

* **실행 계획(Explain)**

<img src="/image/img.png">

* 옵티마이저가 SQL문을 어떤 방식으로 처리할 지를 계획한 것을 의미한다.
* 이 실행 계획을 보고 비효율적으로 처리하는 방식이 있는지 점검하고 비효율적인 부분이 있다면 더 효율적인 방법으로 SQL문을 실행하게끔 튜닝을 하는 것이 목표다.

```sql
EXPLAIN SELECT * FROM users WHERE age = 23;

-- 자세하게(ANALYZE)

EXPLAIN ANALYZE SELECT * FROM users WHERE age = 23; 
```

<img src="/image/explain.png">

* id : 실행 순서
* table : 조회할 테이블명
* type : 어떤 방식으로 조회를 했는지
* possible keys : 사용할 수 있는 인덱스 목록
* key : 실제로 사용한 인덱스
* ref : 조인 연산시 어떤 값을 기준으로 데이터를 조회했는지
* rows : SQL문 수행을 위해 접근하는 데이터 모든 행의 수

### ✅ type 의미 분석하기(ALL / index)

* **ALL** : 풀 테이블 스캔(Full Table Scan)이란, 인덱스를 활용하지 않고, 테이블을 처음부터 끝까지 전부 다 뒤져서 데이터를 찾는 방식이다. 처음부터 끝까지 다 뒤지니 당연히 비효율적이다.

```sql
DROP TABLE IF EXISTS users; # 기존 테이블 삭제

CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100),
    age INT
);

INSERT INTO users (name, age) VALUES 
('Alice', 30),
('Bob', 23),
('Charlie', 35);

EXPLAIN SELECT * FROM users WHERE age = 23; # type : ALL
```

<img src="/image/full%20table%20scan.png">

* **index** : 풀 인덱스 스캔(Full Index Scan)이란, 인덱스 테이블을 처음부터 끝까지 다 뒤져서 찾는 방식이다. 인덱스 테이블은 실제 테이블보다 크기가 작기 때문에 풀 테이블 스캔(Full Table Scan)보다 효율적이나 인덱스 테이블 전체를 읽어야 하기 때문에 아주 효율적이라고는 볼 수 없다.

<img src="/image/index.png">